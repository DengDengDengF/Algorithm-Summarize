[TOC]



## 0.算法总结

```js
1.模型构建(hard)
  动态规划双坐标:最长回文子 o(n^2)
  manacher:最长回文子 o(n)
  最小k:两个有序数组中位数 o(logn)
  以上都是我遇到的，及其刁钻，不是算法熟手，很难一次AC。
2.喝咖啡，补充精力。

bitch
```



## 1.爬楼层体力最小(动态规划)

```
动态规划，核心点抓规律。规律: 
跳一层/跳两层
const=[.........] //每一步花费体力
dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];//找最快的
一句话，跳一层/跳两层，***哪一个花费的体力最小***？
```

## 2.两数之和(哈希)

```
let arr=[2,3,4,5,6,7] target=9   2+7=9  返回下标 [0,5] 假设只有一组符合条件

利用哈希
let obj={};
存储相应数字，以及他们的下标
obj[2]===undefined obj[2]=0
9-7=2
obj[2]!==undefined return [obj[2],5];

时间复杂度 o(n)
```

## 3.两数相加(链表  尾.next=新节点  尾=尾.next, )

让链表的尾指针动起来。

![链表.png](https://s2.loli.net/2023/06/14/Ib3VRJTrCmWoUGi.png)

## 4.不重复的最长字符串(哈希)

```js
let a = "aeedcbddddaddscddd";
规律：从头至尾遍历，遇到字符，看看是否是重复字符，从重复的字符处去遍历，
不要利用js api，尽可能减少时间复杂度 可以利用哈希


官方写法:是一个接一个的去，而不是找重复字符，不过同样用到了哈希 new Set(),效率偏低。
```

## **5.从两个有序数组中，寻找合并后的中位数，时间复杂度***o(log(m+n)) 最小k法  并行二分***

​    log(m+n),首先想到二分法，二叉树，结合数据和顺序之间的关系。

​    往中位数(k)的左侧,过滤***log(m+n)***次数据......，剩下最后一个就是中位数(k)。

​    **5.1当k=k/2的时候，怎么确保排除的一定在k的左侧呢？**

​     <img src="https://s2.loli.net/2023/06/26/lSPMtfY3wjmxDLc.png" alt="image.png" style="zoom: 50%;" />

​      k=9; 

​      k/2=(k-1)/2=4; 从两个数组中找到k=4的位置,4的右侧比4大，12的右侧包括12比4大

​      假设12的左侧都比4小，把4往右侧逼近。

​       n-(k/2 * 2 - 1) >= n-k+1

​                  k/2 * 2 >= -k

​                            k >= k/2 * 2

​      当k=偶数，  k >= k ,成立

​      当k=奇数，  k >= k - 1,成立

​      当k=k/2时候，排除的数字，可以保证在k的左侧。

​    说白了，就是逐渐留下一个k,这个过程一定大于右侧包括k的个数(n-k+1)

​     **5.2 当 k/2 逐渐调整起来呢？**

<img src="https://s2.loli.net/2023/06/26/ksGQF6ncrIEvwdX.jpg" alt="4eb9cc750755e4914cd27b1447a433b.jpg"  />

   逐渐就会填充k的左侧，剩下最后一个，就是k

   **5.3边界条件**

​     1.越界情况调整k。 k的大小已经远大于其中一个数组长度了，k=这个数组length 基本上这中情况只能靠案例刷出来  具体例子

​     A  1 2 3 4

​     B  5 6 7 8 9 10 11 12

​    奇偶区分的时候可以找到

​     2.其中一个数组已经填满了，中位数就在另一个数组的 指针位置+k 处

​     3.k=1,说明下一个就是中位数，两个数组里面找小的值。

  **5.4时间复杂度证明**

   两个顺序数组：

   1 - 1/2 =1/2

   n * (1 / 2) ^ x = 1

​                 2 ^ x = n

​                       x = log2(n)

   三个顺序数组：

   1- 1 / 3 =2 / 3

   n * (2 / 3) ^ x = 1

​       （3 / 2) ^ x = n

​                          x=log 3/2(n)

​    其他类推

   **5.5 coding!!!!**

## 6.字符串中找最长回文(中心发散、矩阵结合动态规划、圆的定义结合Manacher算法)

 **1.中心发散法**

```
例子:d a b c e f e f g e g f e
最长回文为:efgegfe 长度为7
单个字母，肯定是回文，正着来，反着来，都是自己。
多个字母，
       a b a
b是回文，如果左右两侧相等，那么a b a就是回文字符串
      c (a b a) d
在已有的回文基础上，看他的左右两侧是否相等，很明显c a b a d不是回文

利用这个例子，每一个数据，往左右两侧发散(包含a b b a这种，还有 a b a这种)，偶数个的可以 #a#b#b#a# 构造奇数
```

 写代码的时候，我用了哈希，放所有回文，以及他们的长度，最后遍历拿到最长的回文。

 官方demo,用字符串，新回文的长度如果大于字符串的长度，就字符串截取并替换

**2.矩阵结合动态规划--高阶玩法**

![image.png](https://s2.loli.net/2023/06/28/SMoLTZ9jIAnKvWz.png)

***以下是个例子，用来诠释思路，究竟这个动态规划算法，是怎么存储状态的?是怎么把一个大问题化解成若干小问题?***
c是个回文数
如果c回文数的两边有相同字母b呢?b(c)b是个回文数
如果bcb回文数的两边有个相同字母a呢?a(bcb)a是个回文数
........
***即，把一个超级长的回文数，分解成，若干短的回文数***

***用状态去判断是不是回文数***

模型抽象，借用了，矩阵的知识，以下是我的总结

|      |  1   |  2   |  3   |  4   |  5   |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  1   | 1,1  | 1,2  | 1,3  | 1,4  | 1,5  |
|  2   |      | 2,2  | 2,3  | 2,4  | 2,5  |
|  3   |      |      | 3,3  | 3,4  | 3,5  |
|  4   |      |      |      | 4,4  | 4,5  |
|  5   |      |      |      |      | 5,5  |

对角线: i==j ,

上三角: i < j,

从对角线，往右上方移动，i与j的差值，线性增大。

**3.Manacher ----比高阶还高阶玩法**

类似打水漂，详情请看打水漂视频

**1.为了避免像中心发散，分奇 偶的情况，对奇 偶加#，例如 abcd #a#b#c#d#**

2.p:回文中心

   mx：最大回文半径

   R:[ ]//存储每个数据的最大回文半径

   mx=p+R[p]

   <img src="https://s2.loli.net/2023/06/29/9h5uxt3Rpm8OoNl.png" alt="image.png" style="zoom:33%;" />

  i 与 j关于p对称

 所以 (i+j)/2=p

 所以 i=2*p-j; j=2*p-i;

**3.情况讨论**

   例1:

​     <img src="https://s2.loli.net/2023/06/29/R3SYN8EMw2jdXAa.png" alt="image.png" style="zoom:33%;" />

​         mx <= i,无法判断R[i],但是恒定有R[i] >= 1成立

  例2：

​         <img src="https://s2.loli.net/2023/06/29/g1DwSalkRBrizK2.png" alt="image.png" style="zoom:33%;" />

​         mx-i > R[j],

​         又因为 i 与 j关于 p对称，又在对称区间内

​         所以 R[j]=R[i]

   例3:

​         <img src="https://s2.loli.net/2023/06/29/xBoHlvmpeUuLa1P.png" alt="image.png" style="zoom:33%;" />

​          mx-i <= R[j]

​          又因为 i 与 j关于 p对称，又在对称区间内

​           所以恒定有 R[x] >=mx - i一定成立

  tips：不管哪一种情况，最后都要去试一下可以字符串扩展吗，  

​            字符串[i-半径[i]]===字符串[i+半径[i]]，然后半径 [i]++;

​            如果i+半径[i] 超过了以前的右边界，就更新中间值以及右边界

​            如果最大长度 < 半径[i],就最大长度=半径[i],最大长度对应的中心=i

​           循环n此后，就可以拿到，最大长度对应中间、最大半径，然后截取[最大中间-最大半径，最大长度+最大半径]，获取对应的字符串。

## 7.N字形 矩阵、顺序、数学归纳

**1.矩阵 最最最白痴的做法**

<img src="https://s2.loli.net/2023/06/30/KOvwl8fkgHzPdpt.png" alt="image.png" style="zoom: 50%;" />

自己的想法:

用矩阵去解决问题，先要确定矩阵的行和列

行已经给出了，如果行数是1，返回原来字符串

​                           如果行数是2，偶数项和奇数项拼接

​                           .........

​                           记住绝对只有一个数据的列，除了最后一行，和第一行， 行-2

​                           假设其他列可以占满，然后时刻比较和字符串的长度，确定列数  

然后根据给定的行数，列数构建二维数组，默认均为false,然后按照规律往二维数组中填充数据

 规律如下:

​                            记住只有一个数据的列，运用开关去解决，

然后，从第一行开始筛选并拼接字符串，得到最终的z字型数据

***2.官方做法，要么说人家是大佬***

1.  1行就返回原来字符串，行数大于字符串长度，返回原来字符串
2.   正序，开关是true;逆序开关是false;根据开关确定加入第几行
3.   创建一个长度是行数的数组，flag=true 行++；flag=false 行--；arr[行]=str[i];

***3.数学归纳法找规律***

 **row=4**

0                 6                   12                         18
  1            5   7             11     13                17

​    2      4          8    10               14      16

​        3                9                           15

第一行和最后一行   行内数据之间相差6=2*row-2

向下走的的坐标    i % 6  <    4

向上走的坐标        i % 6  >= 4



0      6         12       18

1      7         13       19

2      8          14      20

3      9          15       21

**4     10         16       22**

**5      11         17      23**  

向上走的坐标，只要沿着最后一行的数据(3      9          15       21)翻转上去就行

向上走的坐标，距离最后一行的距离为 i % 6 - (row - 1) 

反转后的坐标，为 row -1 - [ i % 6 -(row -1 )]，简化后 2*row -2-i % 6

综上所述， 

i %  6  <  row  ? arr[i % 6] = str[ i ] :arr[2 * row - 2 -i % 6]

## 8.数字反转输出，并且在[-2^31,2^31-1]范围内，否则返回0

我的做法:找第一个字符   let a = -123; 然后记录下来

​                找123中间值，for循环，然后替换

​                字符串加上存的正负号，转number,

​                在范围内，就返回，否则返回0

数学推导：c语言伪代码示例

```c
// 弹出 x 的末尾数字 digit
digit = x % 10
//除以10向下取整
x /= 10

// 将数字 digit 推入 rev 末尾
rev = rev * 10 + digit
```

用32位去证明，      题目给的就是一个32位的数字，

2^31 - 1=2147483647

-2^31 <= rev*10+digit <= 2^31 - 1 ,无法直接这样证明，有可能rev是个64位数字，那样就不符合题意了

设，右边界INT_MAX=2^31-1=2147483647

​                  INT_MAX=[INT_MAX / 10]*10 + INT_MAX mod 10,     c语言中 “/”除以后会向下取整

​               如果使得  rev * 10 + digit <= INT_MAX 成立

​                       带入  rev * 10 +digit <=  [INT_MAX / 10]*10 + 7,

​                       化简       [rev - INT_MAX/10] * 10 <=7 - digit,

 rev > INT_MAX /10,不成立。因为digit >=0

rev =  INT_MAX/10,成立。digit<=7成立。

rev <  INT_MAX/10,成立。digit <=9成立

综上所述 rev <= INT_MAX/10成立，

rev =  INT_MAX/10，如果还能推，最后推的数字必然是 <=2的 ，//小于9位没问题，等于9位没问题，反正2^31-1是个10为数字。题目限定的输入的是一个32位数字，所以到了第10位的时候，推进去的必然是个<=2的数字，rev <= INT_MAX/10一点问题没有。



同样证述  rev >= INT_MIN/10成立

INT_MIN/10     <= rev <=  INT_MAX/10

## 9.字符串转整数(atoi)

```js
 let str = '    +2222333ssswwww11111';
/*
   遇到空格，continue
   遇到 + - 记录
   遇到数字  记录
   遇到其他 break
   最后数字必须是32位，超过后返回最近的临界值，
   没有符合条件的返回0
*/

第一种方法,无脑条件判断
第二种方法,parseInt(str,10) + 条件判断//第二个参数，进制
第三种方法,正则表达式
第四种方法,取得末尾*10.....,最后查看是否和原来的数字相等，
例子:
      原来数字=101
      新的=1;
      消除末尾后=10；
      
      新的=1*10+0=10;
      消除末尾后=1;

      新的=10*10+1=101;
      消除末尾后=0;

      新的===原来的数字 ?true : false;
```

##  10.正则表达式

<img src="https://s2.loli.net/2023/08/24/eZzsq9Hl1UQTxDW.png" alt="image.png" style="zoom:50%;" />

## 12.盛最多水的容器(递归最无脑的方法n^2、首尾指针n次找到max)

<img src="https://s2.loli.net/2023/09/21/p9LKh1z6oaMt4sv.png" alt="image.png" style="zoom: 33%;" />

```
/ z找最大面积

从开头递归到结尾，重复比较过程，时间复杂度o(n^2)

n+(n-1)+(n-2)+......4+3+2+1=n(n-1)/2=(n^2- n)/2,效率偏低
```

```
level高一点，想办法遍历n次就可以照顾到所有的数据
利用左右指针，左边小左边++，右边小右边--，同时兼容高度小的，遍历n次找到max面积
```

指针的单调性

<img src="https://s2.loli.net/2023/09/22/zBmuJkQvdNaWjXK.png" alt="image.png" style="zoom:50%;" />

## 13.数字转罗马数字

```js
//使用哈希，空间复杂度、时间复杂度都高
使用递归的方式，有一些low
let code = {'1': 'I', '5': 'V', '10': 'X', '50': 'L', '100': 'C', '500': 'D', '1000': 'M'};
let tempCode = {'4': 'IV', '9': 'IX', '40': 'XL', '90': 'XC', '400': 'CD', '900': 'CM'};
已经有了code表示字符了为啥还要用tempCode表示字符?
假如只用code表示,
4=IIII;
9=VIIII;
40=XXXX;
90=LXXXX;
400=CCCC;
900=DLLLL;
由此，推断出，罗马数字不鼓励这么写，即连续相同的4个字符，要把小的放前面，大的放后面，类似 4= 5-1 4=IV;
递归过程省略
```

```js
//使用哈希，空间复杂度高，时间复杂度低 
使用迭代的方式,细节和递归稍有不同
300,存一个 100， 3个100 CCC
600，存一个 500， 500 + 100 =600 DC
核心想法，就是怎么存取最近的哪个值
```

```js
贪心算法//空间复杂度高，时间复杂度低 空间换时间
const valueSymbols = [[1000, "M"], [900, "CM"], [500, "D"], [400, "CD"], [100, "C"], [90, "XC"], [50, "L"], [40, "XL"], [10, "X"], [9, "IX"], [5, "V"], [4, "IV"], [1, "I"]];

143
143 >= 1000 false
143 >= 900  false
...
143 >=100 true  M

143-100=43;
43 >=1000 false 
...
43 >=40; true XL

43-40=3;
3 >= 1000 false
...
3 >=1 true;I

3-1=2;
2 >= 1000 true
...
2 >=1  true I

以此类推，不要忘了拼接
```

```js
硬编码数字 //空间复杂度高，时间复杂度低 空间换时间
//千百十个都给列出来
const thousands = ["", "M", "MM", "MMM"];
    const hundreds = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"];
    const tens     = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"];
    const ones     = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];

3452
3452 / 1000 = 3...452  thousands[3]='MMM'
452 / 100 =4 ...52     hundreds[4]='CD'
52 / 10 = 5 ... 2      tens[5]='L'
2 / 1 =2 ... 0         ones[2]='II'
拼接
```

```
贪心算法：每一步找到当前最优，不考虑之后的，逐层迭代。局部最优解到全局最优解，局部选择后就不改了。
这个题目里，就是类似找零钱，从大的入手，越来越小...
贪心算法，有可能最后找到的不是最优解，贪小便宜吃大亏
```

## 14.罗马转数字

```js
四个连续相同的数字，不符合罗马数字规则， IIII 4 IV,其他以此类推
解决此题，可以用哈希，
存储上一个字符，下一个字符，
上一个字符>=下一个字符 then ....
                    else ....
返回数字
```

## 15.找公共前缀

```js

["flower", "flowe", "flor"] 公共前缀 'flo'
方法一：时间复杂度o(n^2)
      定住首项flower,   max='f'
      查看第二项indexof(max) === 0
      查看第三项indexof(max) === 0
      然后            max='fl'
      ...
      要配合字符串的截取
方法二：
      使用sort排序，底层可能市插入/快排  最差o(n^2),最好o(nlogn)
      ['flor','flowe','flower']
      比较第一项和最后一项
      ....
      
方法3 分治策略 归并思想
      先分解到最小元素，然后提取公共前缀
      利用提取到的公共前缀，和其他分解到的子元素，进行比较继续提取公共前缀
      ...
      层层合并后找到公共前缀
      花里胡哨,用这种方法，纯粹就是训练归并思想，绝对不是解题的最优。
```

<img src="https://s2.loli.net/2023/08/02/1ZGTUPEeCgomQpD.png" alt="image.png" style="zoom: 50%; margin-left: 0px;" /><img src="C:/Users/ldf/AppData/Roaming/Typora/typora-user-images/image-20230802171235551.png" alt="image-20230802171235551" style="zoom: 50%;" />

```
方法4:
https://leetcode.cn/problems/longest-common-prefix/solution/tu-jie-leetcodezui-chang-gong-gong-qian-zhui-lcp-b/
字典树，

和链表的思想极为相似，类似算法题第二题 两数相加用链表去做
1.树的添加，确保next存在，然后往根节点的next中添加数据。

2.树的搜索
let strs=['flower',"flower",'flower','flowers'];
注意看第一个isEnd=true   字符串flower

let strs=['flower',"flower",'flower','flows'];
注意看 其中一个next下面有 > 1个元素,排除掉这个，他前面的都要，  字符串flow
```

## 16.三数之和是0，切不重复，时间复杂度尽可能低

```js
输入：[-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
我的思路：题目要求nums.length最大在3000,如果用时间复杂度o(n^2)粗略估计在9*10^6次，故pass掉，另辟蹊径
先对数组进行排序，排序选择归并排序，o(nlogn);
问题来到了，如何去找另外两个相加为-nums[i]的，使用二分法双指针时间复杂度o(n),加上外层循环n次
o(n^2),去重用了哈希。
总体时间复杂度o(n^2),缺点：空间复杂度高，用空间换时间

官方思路：
也是用了双指针，不过去重上有区别
排序用了sort,属于交给浏览器引擎，自动选择排序方式是快排/插入/归并
[-1,0,1,2,-1,-4]
排序后[-4,-1,-1,0,1,2]
双指针
-4开头的，继续
-1开头的，继续
-1开头的，跳过,去重
0开头的， 继续
1开头的， break,往右边都是比1大的不可能三数相加是0
2开头的,  break,往右边都是比2大的不可能三数相加是0

还有用哈希暴力去重的，
```

## 17.最接近的三数之和

```js
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
题目设定了,nums最大长度 1000，target最大10^4,
我的想法:
      时间复杂度o(n^2),完全应对的了
      思想还是双指针，和 ‘三数之和是0’做法几乎一样
      let obj={
          min:Math.pow(10,4),
          origin:''
      }
      循环加双指针加条件判断，三树之和-target 的绝对值，小于等于obj.min right--,看看有没有更小的
                                                 
```

## 18.电话号码字母组合（动态规划启蒙运动、dfs深度优先搜索、bfs广度优先搜索）

 1.动态规划

```js
let 电话号码表={'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'};
我的理解:题目出的数据规模这么小，意味着这个题的时间复杂度低不了，放手干吧！！
输入2
输出 ['a','b','c']

输入3
输出['ad','ae','af','bd','be','bf','cd','ce','cf']

输入4
输出['adg','adh','adi','aeg','aeh','aei','afg','afh','afi',.......'cfg','cfh','cfi']

dp[current]=dp[before]+dp[i]
3 + 3^2 + 3^3 + 3^4,十分垃圾的计算方法
```

 2.dfs(depth first search)，侧重深度

算法过程，如下：

<img src="https://s2.loli.net/2023/08/07/pycRLKx6EwZok7D.png" alt="1.png" style="zoom:33%;" /><img src="https://s2.loli.net/2023/08/07/jAKEOWZIXs26lNP.png" alt="2.png" style="zoom:33%;" /><img src="https://s2.loli.net/2023/08/07/yGnwWUSqCePzJIQ.png" alt="3.png" style="zoom: 33%;" /><img src="https://s2.loli.net/2023/08/07/mi6MtkOb8Sv1Dfp.png" alt="4.png" style="zoom:33%;" />

```js

持续滑动指针，持续添加数据;

全部指针滑动到末尾，全部数据添加完毕

思想：沿着一条路径，一直搜索下去，无法搜索就回退，包含递归思想，无法搜索就相当于，递归的终止条件。

代码实现,略
```

3.bfs(breadth first search),侧重广度

算法过程：

<img src="https://s2.loli.net/2023/08/07/M1PxOuzaNEHwWTR.png" alt="image.png" style="zoom: 50%;" />



```js
思想，每一层去搜索，往下一层走。广度。
队列先进先出，删除头部和添加尾部，会对队列产生影响，遍历的时候要注意，避免出现死循环。
```

## 19.四数之和(双重for循环+二分法+剪枝优化)

```js
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
我的观点：核心点在于去重。
先从小到大排序，然后for循环去重，双重for循环+双指针，时间复杂度o(n^3),题目最大数据规模200符合题意
二分法,去重
while(left < right){
    if(condition ===target){
         //去重
         while(left < right && num[left] === num[left+1]){
             left++;
         }
         left++;
         //去重
         while(left < right && num[right] === num[right - 1]){
             right--;
        }
        right--;
    }
    if(condition  > target){
        right--
    }
    if(condition < target){
        left++
    }
}
参考三数之和


官方做法：
排序,双重for循环+双指针，
for循环去重，均要确保前后两个值不一样，
去重剪枝的细节如下：
确定第一个数，如果 nums[i]+nums[i+1]+nums[i+2]+nums[i+3] > target,break,i<i+1,nums[i+1]+.....一定>target
           如果 nums[i]+nums[str.length -3]+nums[str.length - 2] +nums[str.length -1] < target,continue,
              i<i+1 nums[i+1]+.....和target关系
              
确定第二个数，如果nums[i]+nums[j]+nums[j+1]+nums[j+2]>target,break
            如果nums[i]+nums[j]+nums[str.length-2]+nums[str.length-1]<target,continue, 
                
双指针去重，就是和目标值相等后，left++,right--,同时加上去重操作


```

## 20.删除链表倒数第N个节点

```js
看清楚题意，利用双指针，当某个指针，移动到末尾后，双指针之间的差值为n。
```

 1.双指针定位头部，其中一个指针移动n个位置

<img src="https://s2.loli.net/2023/08/08/4CnZTWk6y9KDw1o.png" alt="1.png" style="zoom:33%;" />

  如果，移动到的位置的next=null,说明要返回倒数第n个，这个n就是数据长度，返回head.next就可以，把第一个剔除掉

2.双指针，同时移动，直到fast指针的next=null,这时，移动到了要排除的地方slow处。

<img src="https://s2.loli.net/2023/08/08/5FUAxLeBvk6XIJM.png" alt="2.png" style="zoom:33%;" />

slow.next=slow.next.next;

## 21.有效的括号

```js
s='()' true;
s='(){}[]' true;
s='({)}' false;
数据规模最大 10^4,所以要求最低时间复杂度nlogn,我用了一个o(n)的方法
当传入的数据长度是个奇数的时候，绝对不是有效的 类似 '(({}{})'
四个数组分别存储'{' '(' '['的下标，
当循环到 '}' ')' ']'时，检查当前右括号坐标，和左括号的坐标差值，差值是偶数，一定不是有效的，类似 '({)'。当差值是奇数要考虑这一种'({})'，还有'({)}'。
类似栈：先入后出，匹配的过程就是出栈的过程。


官方做法：
用了jsapi replace
长度是奇数返回false
长度是偶数，继续
循环字符串长度的一半，因为 '()' '{}' '[]'都是对称的  
s = s.replace("()", ""); 
s = s.replace("{}", "");
s = s.replace("[]", "");
return s.length === 0;
如果s='{({})}'=> '{()}' => '{}' => '',len/2次出结果
如果s='{({)}}' => '{({)}}' => '{({)}}' => '{({)}}' 

取巧做法：
Math.random() < 0.5 ? true : false;交给天意
```

## 22.合并两个有序链表

```js
输入：list1 = [1,2,4], list2 = [1,3,4]
输出：[1,1,2,3,4,4]
最多50个节点。
我的想法：根据两个升序链表，合并出也给新的升序链表，时间复杂度o(n)
利用双指针。l1是list1的指针、l2是list2的指针，

 
官方做法：递归做法，本质还是双指针。但是写法明显高出了好几个level
         迭代做法，本质双指针，主打一个简练
官方做法都是根据图去写代码的，要知道当前节点的next应该是谁?next的含义
```

递归做法:数据插入，思想水平高出好几个level

![image.png](https://s2.loli.net/2023/08/09/bimsXCNHSD819UG.png)

迭代做法：主打一个简约，没有一句话是废话。

<img src="https://s2.loli.net/2023/08/09/ijPerx3hHDMqnZc.png" alt="image.png" style="zoom:50%;" />

## 23.括号生成(抽象树，dfs回溯+减枝)

一定要先问题抽象构思，再写代码，如何运用递归，解决这种输入不确定性的问题。

1.暴力dfs深度递归：时间复杂度 （2^2n）*n，

<img src="https://s2.loli.net/2023/08/11/xHBdYcXGsbWMjDl.png" alt="image.png" style="zoom: 50%;" />



每一层往下，就是要么左括号，要么右括号。

```js

const dfs=(str)=>{
  if(str.length === n*2){
      if(符合规则){
          //添加进数组
      }
  }
  let left=....;
  dfs(left);
  let right=...;
  dfs(right); 
}
```

2.dfs回溯+减枝

代码层面:

和暴力dfs回溯比较，暴力回溯，就是把判断条件给独立出去了。

加入减枝，就是把递归和条件融合，达到一种优化

数据解构层面：减枝后，回溯。

<img src="https://s2.loli.net/2023/08/11/fcSrEVjABC1h6ys.png" alt="image.png" style="zoom: 25%;" />

```js
const dfs=(str,open,close)=>{
  //递归过程当右括号比左括号多，绝对不符合。类似(()))。
  //当左括号比n都多，因为题目要去要2n，左括号比一半都多，一定不符合
  if(close > open || open >n) return
  if(str.length === n*2){
      //添加数组
      return
  }
  let left=....;
  dfs(left,open+1,close);
  let right=...;
  dfs(right,open,close+1); 
}
dfs('',0,0)
```

3.回溯加减枝 ，奇怪的手段

只要左括号还有剩余，就选左括号。

剩下的右括号比左括号多，就选右括号

输入数据=3， 左括号3个，右括号3个，如图下

![image.png](https://s2.loli.net/2023/08/11/zmyr6gHoLFSU7ki.png)

```js
 const dfs = (left, right, str) => {
            if (str.length === n * 2) {
                res.push(str);
            };
            if (left > 0) {
                dfs(left-1, right, str + '(');
            }
            if (right > left) {
                dfs(left, right-1, str + ')');
            }
 };
 dfs(n, n, "");
```

## 24.合并K个升序链表

```js
链表数组如下：[1->4->5,1->3->4,2->6]
将它们合并到一个有序链表中得到。1->1->2->3->4->4->5->6

题目给出lists[i].length <=  10^4;
方法一更加暴力求解:
对于每个list[i],两两合并，
两两合并，用递归做数据插入。

方法二暴力求解：
链表转成数据，推入数组，
数组排序后，转成链表

方法三：无序数组分治思想找到最小值，移动最小值的指针，细节略。



官方做法:
1.分治思想，归并法，把若干链表，层层减半，两两排序，排序用的是22.合并两个有序链表方法
2.最小堆，代码写了一大堆，啰里啰唆的。如果看到写的少,还用了堆排序，肯定是用了api了
   如果是最小堆排序，流程如下:
        1.构建堆，
            1.1从下到上 父节点:n=Math.floor(length / 2) -1 ----->0;
                       左:2n+1
                       右:2n+2
            1.2从上到下  从头到尾，每一个节点满足----->父节点:Math.floor(当前节点下标-1)/2
                     左/右:当前节点坐标
        2.顶部与尾部交换
        3.继续从上到下堆排序，
        
    如果是链表堆排序，流程如下
         1.构建堆，推入一个坐标就检查父子关系，最终得到顶部最小
         2.取出顶部，顶部=尾部，删除尾部，此时length--
         3.对length--后的再次堆排序，//leetcode算法做了一个折中处理，针对null不加入，但是下一次也要拿到最小值，所以上一波儿length--后，堆一次，
         4.原来min的next推入尾部
         5.以上要排除Null的情况，null不入堆

```

## 24.1堆排序一次性解决问题

```js
1.构造完全二叉树
2.从下到上，右到左，构造大(小)顶堆。
3.堆顶元素和尾部元素交换
4.重复2 3步骤

注意:  父:  n=Math.floor(len / 2) -1
     左子:  2n+1
     右子:  2n+2
设计巧妙的点:每次堆比较不会己算已经添加堆底的(max/min);
时间复杂度、空间复杂度、稳定性分析：
1.时间复杂度:  8:4 7:3 6:3 5:2 4:2    (数据量:比较次数)
             接近log2n
             比较n-1次，剩下最后一个不用比较
             (n-1)logn=nlogn-logn
             总体理论时间复杂度o(nlogn) ,
             实际复杂度接近o(n^2),实际比较差。
2.空间复杂度   只用变量来交换 o(1)
3.稳定性       1 2a 2b 5
  使用堆排序后  1 2b 2a 5, 不稳定。
```

小顶堆

<img src="https://s2.loli.net/2023/08/15/R5m2MXdh1QOtkIj.png" alt="image.png"  />

大顶堆

<img src="https://s2.loli.net/2023/08/15/zLCjepHa8AKsXDP.png" alt="image.png" style="zoom:50%;" />

## 25.两两交换链表中的节点

```js
输入：head = [1,2,3,4]
输出：[2,1,4,3]
我的看法:题目要求不能修改值，进行节点交换。
链表，层层靠着地址联系。
head.next=head;这种情况容易死循环
用的深拷贝。

官方做法:真真正正的链表之间节点的关系，通过指针连接，相比之下，我的做法虽然提交成功，但是思路明显错误。
```

<img src="https://s2.loli.net/2023/08/21/P4SYU3duRbNck1a.png" alt="image.png" style="zoom:50%;" />

## 26.K个一组反转链表

```js
分阶段
每个阶段的头和尾
每个阶段是否有必要调整指针位置
更考察代码设计能力
```

## 27.删除有序数组重复项

```js
1.把重复元素先替换成 "";
2.非重复元素 当作 key 推入哈希,value存储新的位置
3.根据哈希，放到数组的位置
4.其他地方填写 ""
o(3n)

官方做法
双指指针之快慢指针

```

![image.png](https://s2.loli.net/2023/08/30/eEl9v3NWjOGuLbU.png)

## 28.移除元素

```
快慢指针(双指针)
```

## 29.找出第一个字符串匹配下标

```js
kmp解法
关键在于 找到最长前后缀表
needle                           a   a    b    b    c    c
跳过几个元素                       0   1    0    0     0   0
然后正常遍历，根据最长前后缀表，跳过元素，达到时间复杂度优化。
let n=needle.length;
let next=new Array(n).fill(0)
for(let i=1,j=0;i<n;i++){
    while(j>0 && needle[i] !== needle[j]){
         j=needle[j-1]
    }
    if(needle[i] === needle[j]) j++;
    next[i]=j
}
next就是前缀表
```

<img src="https://s2.loli.net/2023/10/03/jr2aRygbVTFC8Is.jpg" alt="屏幕截图 2023-10-03 145634 _1_ _1_ _1_.jpg" style="zoom: 33%;" />

## 30.两数相除

```js
这个题目，不让用乘法、除法、取余。
如果人家给的例子是(2^31-1,1),用1+1+1+1...要己算2^31-1次，21亿次了，肯定超时。中国超算-神威太湖之光（运算速度：12.5亿亿次）,只要不是死循环，这玩意啥不是秒秒秒
我的做法用的二进制
加法
0+0=0;
0+1=1;
1+0=1;
1+1=10
减法
0-0=0;
1-1=0;
1-0=1;
0-1=1;(要借位，借位的过程中经过的都会被高位分配。)
```

<img src="https://s2.loli.net/2023/09/03/ZHabnlUTd8GN1zg.png" alt="image.png" style="zoom:33%;" />

```js
另一种做法是 用  >>>  >> << ,  >>>是无符号右移   >>是右移  <<是左移
2147483648 >> 31 结果-1
2147483648 >>> 31 结果1
具体应用如下
a=100,b=4;求商res?
    (100 >>> 31) >= 4   ×
    (100 >>> 30) >= 4   ×
            ......
    (100 >>> 4)  >= 4   √   ------>    a-=b<<i;res +=1 <<< i;   a=36; res=16;
    (36  >>> 3)  >= 4   √   ------>    a-=b<<i;res +=1 <<< i;   a=4 ; res=24;
    (4   >>> 2)  >= 4   ×
    (4   >>> 1)  >= 4   × 
    (4   >>> 0)  >= 4   √   ------>    a-=b<<i;res +=1 <<< i;   a=0 ; res=25;
最后结果 res 
```

## 31.快速幂-分治

```js
实现类似js Math.pow(x,n);
这两种分治思想都有回溯，但是为了直观体现，借助典型从后往前回溯。
```

<img src="https://s2.loli.net/2023/10/04/1FphtIkwoNx6naC.png" alt="image.png" style="zoom:50%;" />

## 32.串联所有单词的子串

```js
输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
这个题目有点坑，有个隐藏的条件是，words中每一个单词长度是一样的。
我先想的是用深度优先、广度优先、结果剪枝去重后，数据量还是大的离谱，
后来采用的是，
1.用哈希存储words中每个数据，重复数据对应的value+1;
2.循环s串，如果截取word[0].length个单位后，不匹配就下一个
3.建立哈希存储s串临时数据，每个临时数据都要和words的哈希比较，是不是超了?是不是不存在
4.合适坐标的推入数组。

官方题解：
滑动窗口:
m=words.length,n=words[0].length;ls=s.length;diff=new Map()
1.对words先添加一遍哈希,diff中的该项+1
2.遍历s串，以n为间隔，遍历n*m次,diff中的该项-1，如果该项===0,删掉！
3.diff.size===0就符合要求
4.右窗口扩大，做窗口缩小。右扩的时候diff中该项-1，左缩的时候对应项+1
5.diff.size ===0就符合要求
```

<img src="https://s2.loli.net/2023/09/09/Cbt4eMVKyJ3x9oB.png" alt="image.png" style="zoom: 67%;" />

## 33.下一个排列

```js
输入:nums=[1,2,3,10,9,8,7,6]
输出 [1,2,6,3,7,8,9,10]
我的做法：
从右向左找第一个小于后面的 a=3,
从右向左，第一个大于a的 b=6
a、b换位置，
a右侧的从小到大排序，排序可以从中间两侧两两交换。

官方的规律和我的一样，但是代码写起来，明显感觉人家写的优雅太多了
```

## 32.最长有效括号(hard)

```js
输入：s = "(()()(()()()"
输出：3
解释：最长有效括号子串是 "()()()"

我的做法:
stk=["(",'*','*','(','*','*','*'];
看哪边的 '*'的数量多，

1.遇到没有 '合并'的加入stk数组中
2.遇到 ')'可以在stk中找到 '(',也包括 '*'之前的'(',用了个指针往回找
3.用哈希存储每个间隔左侧的'*',当这个间隔处被划分成'*',加上对应哈希处的值
4.max
我猜想，官方做法应该在我用指针往回找的时候做优化了，官方设计的比较巧妙，真正能看出那个是间隔

官方做法:
以下几种情况
    * 1. ')))()' 开头的')))'
    * 2. '((()' 开头的'((('
    * 3. '()()(()()()' 中间的'('
    * 4. '()()(()()())'
    * 5.  '()())()()() 中间的')'
     利用栈去解决问题
        入栈 -1;
        遇到 '(',入栈;
        遇到')',出栈;如果栈的长度===0,入栈当前坐标;反之临时长度=i-栈(栈长度-1),比较....
```

<img src="https://s2.loli.net/2023/09/12/3Xj2J78WysaCg5p.png" alt="image.png" style="zoom: 67%;" />

```js
比较狠的动态规划:
const dp=new Array(s.length).flll(0);默认最长有效括号都为0
在s[i]===')'下
1.s[i-1] === '('
   1.1 '( )' dp[i]=2
   1.2 ') ( )' dp[i]=dp[i-2]+2;
2.s[i-1]=')' 且 s[i-dp[i-1]-1]='('
   2.1  '( ( (  ) ) )' dp[i]=dp[i-1]+2
   2.2  '( )( ( (  ) ) )'dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]
```

## 33.搜索旋转排序(二分法刷新认知了，单行两个有序)

```js
 [4,5,6,7,8,1,2,3] target='xxxx';
  如果target===nums[mid]找到了
  每次二分都要想，mid的左边还是右边绝对是有序的
  例如，nums[mid]=7,nums[left]=4,我能确定的就是4~7这个区间是有序的
  如果 target < nums[left] || target > nums[mid]  left=mid+1
  ....
  例如 nums[mid]=2,nums[left]=4,我能确定的是2~3这个区间是有序的
  如果 target > nums[mid] && target < nums[right] left=mid+1;
  ...
```

## 34.在排序数组中查找元素 logn

```js
  [1,2,2,3,3,4,5,6] 找到3    [3,4]
  [左，右]
  用二分法找区间的左和右，抽象一点就是，
  left++ 逐渐找到右
  right--逐渐找到左
  合并
```

## 35.搜索插入位置

```js
输入: nums = [1,3,5,6], target = 5
输出: 2
输入: nums = [1,3,5,6], target = 2
输出: 1
二分法，正常找target
but
 if(nums[middle] < target){
         left=middle+1
         ans=left;  //最后的
 }
```

## 36.有效数独

```js
有效的数独满足以下三个条件：
1.同一个数字在每一行只能出现一次；
2.同一个数字在每一列只能出现一次；
3.同一个数字在每一个小九宫格只能出现一次。
运用哈希 {'1': 0, '2': 0, '3': 0, '4': 0, '5': 0, '6': 0, '7': 0, '8': 0, '9': 0}
我的做法 条件一条件二分别检测
条件三，通过行列构造实现
```

## 37.回溯算法，解数独

```js
题目可以用回溯算法，结合二叉树数据结构，
每一个空缺位置1~9挨个儿去试，试成了，看下一个....
如果空缺位置1~9都试了，都不行，说明上一个有问题，回溯回去....
回溯回去上一个位置，继续1~9去试....
直到最后都填满了，没空缺位置了。
可以结合代码进行优化。

let board = [["5", "3", ".", ".", "7", ".", ".", ".", "."],
        ["6", ".", ".", "1", "9", "5", ".", ".", "."],
        [".", "9", "8", ".", ".", ".", ".", "6", "."],
        ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
        ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
        ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
        [".", "6", ".", ".", ".", ".", "2", "8", "."],
        [".", ".", ".", "4", "1", "9", ".", ".", "5"],
        [".", ".", ".", ".", "8", ".", ".", "7", "9"]]

    //行、列、9×9
    function isValid(board, x, y, value) {
        //每一行
        for (let i = 0; i < 9; i++) {
            if (board[x][i] === value) return false;
        }
        //每一列
        for (let i = 0; i < 9; i++) {
            if (board[i][y] === value) return false;
        }
        //3×3
        let row = Math.floor(x / 3) * 3, col = Math.floor(y / 3) * 3;
        for (let i = row; i < row + 3; i++) {
            for (let j = col; j < col + 3; j++) {
                if (board[i][j] === value) return false;
            }
        }
        //三个条件都不重复，返回true
        return true;
    }


    var solveSudoku = function (board) {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (board[i][j] !== '.') continue;
                //每一个空缺的位置都要 1~9挨个去试
                for (let num = 1; num <= 9; num++) {
                    //填入的数字符合规则了
                    if (isValid(board, i, j, String(num))) {
                        board[i][j] = String(num);
                        if (solveSudoku(board))  return true;
                        board[i][j] = '.';
                    }
                }
                //填入1~9没一个能行的，说明上一个出问题了，上一个就得继续1~9找下一个
                return false;
            }
        }
        //棋盘遍历完了，说明都填满了，且都符合规则了
        return true;
    };
```

<img src="https://s2.loli.net/2023/09/16/BgMdImKWexjUSEQ.png" alt="image.png" style="zoom:50%;" />

## 38.外观数列

```js
1.  1
2.  11
3.  21
4.  1211
5.  111221
第一项 1
第二项 前一项1     1个1        11
第三项 前一项21    2个1        21
第四项 前一项1211  1个2,1个1   1211

注意前一项的前后关系就好了，其他就是一些代码设计细节
```

## 39.回溯算法-组合总和

```js
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
组合问题可以用回溯算法，不合适就顺着二叉树倒腾上去。
```

![image.png](https://s2.loli.net/2023/09/18/Copkc4DI7qJeZla.png)

## 40.回溯算法剪枝-组合综合II

```js
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:[[1,1,6],[1,2,5],[1,7],[2,6]]
同样也是个组合问题，不过加了一个剪枝
```

<img src="https://s2.loli.net/2023/09/19/J47Piv1FbVYpdxA.png" alt="image.png" style="zoom:50%;" />

## 41.手写哈希表-缺失的第一个正数(hard),时间复杂度o(n) 空间复杂度o(1)

```js
输入：nums = [3,4,-1,1]
输出：2
直接用哈希  时间复杂度o(n) 空间复杂度o(n)不符合要求
怎么常数级别空间复杂度是个难点。还有代码设计能力，体现在代码中的while循环。

构造临时哈希！
要找的数在[1,N+1]里面(N为数组长度),最后N+1不用找，前面N个元素找不到，返回N+1
把原始数组构造成哈希数组
原始数组 [3,5,7,1,2] length=5
哈希数组 [1,2,3,7,5] 7这个位置怪怪的。
原始数组 [6,5,4,2,3,1]
哈希数组 [1,2,3,4,5,6] 返回6+1
代码里用 while,为了防止nums[i]交换后仍然不符合条件，不要想用while就时间复杂度o(n),这里nums[i]临时交换次数是常数级的
```

<img src="https://s2.loli.net/2023/09/20/G7ibPMeSfFspz5Z.png" alt="image.png" style="zoom:50%;" />

## 42.接雨水(动态规划、双指针)

<img src="https://s2.loli.net/2023/09/21/FMix9NyfZGjHvDn.png" alt="image.png" style="zoom:50%;" />

```js
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。


我的做法，我使用了快慢指针。
慢指针记录临时左坐标,快指针记录临时右坐标。当height[快] >= height[慢]求单位区域面积
并且 慢=快，更新慢指针。
我图上画的是，临近末尾的时候，没有找到比慢指针位置处大的
那么，记住慢指针位置，从右往左，当height[快] < height[慢]求单位区域面积
面积累加，然后返回即可


官方做法:
动态规划
通过观察得知，左右两列不可能存水
中间的这些，能存水的, 左侧最高柱子- 水-右侧最高柱子
等于我要找到水我就得知道，这个点的 (左侧最高[i]与右侧最高[i])min - height[i]。
如果min值都小于等于height[i]肯定存不住水，类似我画的图二里面的 坐标10
let max_left[i]=Math.max(max_left[i-1],height[i-1]);
let max_right[i]=Math.max(max_right[i+1],height[i+1])
一点都不快，太费空间了 max_left=Array(length).fill(0)  max_right=Array(length),fill(0)
```

```js
双指针
```

<img src="https://s2.loli.net/2023/09/22/jU5fbvmOheuaLxR.png" alt="image.png" style="zoom:50%;" />

## 43.字符串相乘(代码设计能力)

```js
输入: num1 = "2", num2 = "3"
输出: "6"
要求 '999999999'*'99999999999999'不能以指数形式输出，不能直接相乘
我的做法:空缺补0、乘法加法相结合，一边乘一边加，不过要考虑的情况太多。
```

<img src="https://s2.loli.net/2023/09/25/tPlsVSvpYFXmKek.png" alt="image.png" style="zoom:50%;" />

```js
官方做法:用了一个数组，完美处理了补0的问题，以及乘法与加法结合,解决了各种兼容问题。
代码的闪光点如下:
let value=a*b+res[i+j+1];
res[i+j+1]=value % 10;//
res[i+j]+=value / 10 |0; //完美处理下一次的，value相加问题，
```

<img src="https://s2.loli.net/2023/09/25/L4vxYNVXIFb5Ump.png" alt="image.png" style="zoom:33%;" />

## 44.通配符匹配(hard)动态规划

```js
参考10.正则表达式
唯一修改的就是 ‘*’对应的逻辑
正则表达式，那个'*'代表的逻辑是‘瞻前’
通配符，'*'代表的是’顾后‘，设计动态规划的人绝对天才！
```

![image.png](https://s2.loli.net/2023/09/25/RZ7HUJYT6rp5EqW.png)

## 45.跳跃游戏 II(middle)贪心

```js
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置
     
我做了适当的剪枝，最后通过下标跳转的方式记录跳了几次。详情看leetcode我写的源码。
```

<img src="https://s2.loli.net/2023/09/26/RxCAlWmJezfi98u.png" alt="image.png" style="zoom:50%;" />

```js
官方用了贪心算法:
数字转罗马，也用了贪心，让其局部递减，直到结尾
1950 转罗马
let valueSymbols = [[1000, 'M'], [900, 'CM'], [500, 'D'], [400, 'CD'], [100, 'C'], [90, 'XC'], [50, 'L'], [40, 'XL'], [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'], [1, 'I']]
1950-1000=950  'M'
950-900=50 'CM'
50-50=0 'L'
最后结果 'MCML'

这个题目是，局部增加到极限，直到结尾
其他的就是一些代码设计问题。
```

<img src="https://s2.loli.net/2023/09/27/68jSzOeqgtMXhNw.png" alt="image.png" style="zoom: 50%;" />

## 46.全排列 回溯算法

```js
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
我的做法用的回溯算法 加 上一些js数组操作concact,
```

<img src="https://s2.loli.net/2023/09/29/vPuyjheNMX9Am2Y.png" alt="image.png" style="zoom: 50%;" />

## 47.全排列II 回溯算法

```js
输入:nums=[3,3,0,3]
输出:[[0,3,3,3],[3,0,3,3],[3,3,0,3],[3,3,3,0]]
先排序
回溯算法
剪枝if(nums[i] === nums[i-1])continue;
回溯算法看似复杂度高，但是问题只有这种算法能解。所以用回溯算法的数据规模一般都不大。
```

## 48.旋转图像 算是双指针算法一半交换 横纵交换

```js
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
题目要求只能原地修改
我的思路是:矩阵(1/2)翻转以及翻转后的交换
经过测试，交换的时候用js es6的解构赋值 [ , ]= [ , ],时间复杂度以及空间复杂度都要比 临时变量存储的方式要 高。
这个题目的流程如下图所示:
```

<img src="https://s2.loli.net/2023/10/01/oPQMn7Z6mwFv8d9.png" alt="image.png" style="zoom:50%;" />

## 49.字母异位词分组（哈希）

```js
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
异位词:就是字母重新组合 asd ads dsa....
我用的比较巧妙的哈希+数组引用，高效解决问题。
```

<img src="https://s2.loli.net/2023/10/02/JSaiYmsOelpxzbZ.png" alt="image.png" style="zoom: 67%;" />

## 50.N皇后I II(hard 回溯 哈希)

```js
不能同行、不能同列、不能同斜线上
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
回溯算法+代码设计
但是时间复杂度有点高，推测是代码设计问题占用大量空间同时也会引起时间复杂度变高。
官方题解，用的哈希去校验规则，比不用哈希校验的平均快了100ms。
```

<img src="https://s2.loli.net/2023/10/05/nPUjKDm1WC7YFsv.png" alt="image.png" style="zoom:50%;" />

## 51.最大子数组和(线性条件硬解算法、单调性动态规划算法、分治法)

```js
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
我的做法:先尝试了o(n^2),在给数据规模10^4情况下超时了
然后尝试，数据之间的关系，数据之间和max之间的关系，绘制逻辑图，完成。
```

<img src="https://s2.loli.net/2023/10/05/s1tQk9obqNjeHCw.png" alt="image.png" style="zoom:50%;" />

<img src="https://s2.loli.net/2023/10/05/ew1FoEbrqzWJfkC.png" alt="image.png" style="zoom:50%;" />

```js
官方的更牛逼，动态规划思想、单调性思想
遇到这种问题，要想极端情况、融合极端情况、类似双指针单调性思维。
[-10,-2,-1,-4,-5]  sum<0是无益的   sum<0   sum=当前值    max=Math.max(sum,max);
[10,3,4,5,6,0,12]   sum>=0是有益的  sum>=0  sum+=当前值   max=Math.max(sum,max);

[-2,10,-12,3,1,4,6,-100]    sum>=0 sum+=当前值
                            sum<=  sum=当前值
                            max=Math.max(sum,max);
类似接雨水，有动态规划推出的规律，----->左侧的max;右侧的max <------;使用单调性思想结合双指针讨论极端情况、极端情况融合优化空间复杂度。
```

```js
分治法
_ _ _ _ _ _m、m+1_ _ _ _ _ _
1.m      左侧找到最大连续子数组(包含m)
2.m+1  右侧找到连续最大(包含m+1)

_ _ L_ _ _ _m、m+1_ _ _ _R_ _
3.L~m 并且 m+1~R 区间才是最大连续子数组

总结,然后这三个条件最大的那个就是max.
tips:用这个方法，分治法得分治坐标，不能分治数组了。
```

![image.png](https://s2.loli.net/2023/10/06/qiL3lWxseZQ5R8B.png)

## 52.螺旋矩阵

```js
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
我的做法，递归这个有小缺口的长方形，代码设计要用到栈和队列的思想。就是空间复杂度高
```

![image.png](https://s2.loli.net/2023/10/07/512qg4dVFZlhrxb.png)

```js
另一种做法用到了 两对双指针，同时向内收缩。
```

<img src="https://s2.loli.net/2023/10/08/8SviH2hQcE5GKLm.png" alt="image.png" style="zoom:50%;" />

<img src="https://s2.loli.net/2023/10/08/gGaA437CfpBP859.png" alt="image.png" style="zoom:50%;" />

## 53.跳跃游戏

```js
输入：nums = [2,3,1,1,4]
输出：true
输入：nums = [3,2,1,0,4]
输出：false
第一种方法：动态规划
[1,4] 可以到达
[0,1,4]不可以到达，
就是说，如果要到达后面的，前面的值必须>=下标差。
var canJump = function(nums) {
        let end = nums.length - 1;
        for (let i = nums.length - 2; i >= 0; i--) {
            if (end - i <= nums[i]) {
                end = i;
            }
        }
        return end == 0;
};
```

<img src="https://s2.loli.net/2023/10/09/ZhMVrxPwIvuFU4C.png" alt="image.png" style="zoom:50%;" />

```js
第二种贪心
和跳跃游戏II类似。
```

## 54合并区间(时间复杂度和空间复杂度会相互影响、贪心算法)

```js
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
第一种暴力法
先按照二层数组首项，从小到大排序
再从左至又利用双指针做判断以及删除元素
最后返回intervals;
```

![image.png](https://s2.loli.net/2023/10/09/Z2h7zrJtlDA3X4u.png)

```js
第二种分治法
分治排序的过程中，去操作数组，逻辑和上面一样
比暴力法快了平均100ms
就是这个空间复杂度有点高，时间复杂度击败全国64%用户。
第三种用哈希
哈希排序、哈希合并、哈希转换时间复杂度也不怎么地。
```

```js
官方思路跟我第一种一样，纯纯就是人家设计的巧妙。
我写的删除用了个slice,这个方法移动坐标太费时间
人家官方写的不用删除主要就是贪心思想的差距。我写的代码与官方对比，我成了下等马
贪心算法
if (target[1] >= val[0]) {
       //有了交集了
        target[1] = Math.max(val[1], target[1]);
 } else {
        //没有交集先把上一个ok的push
        res.push(target);
        target = val;
}
```

<img src="https://pic.leetcode-cn.com/1605533694-FwbfEY-image.png" alt="image.png" style="zoom: 25%;" />

## 57.插入区间

```js
输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
1.参考合并区间的方法
  先push进去，再排序，然后贪心
2.参考最大子数组和分治思想分成 左、中、右，三个区间。
  做法上虽然用了双指针,但是思想上用了"部分分治思想"
  左区间    newInterval[0]>intervas[1]
  中间驳杂   newInterval[1]>=intervals[0]  调整newInterval的[start,end]
  右区间     剩下的就是
 按理说，第一种方法的时间复杂度是o(nlogn+n),第二种方法时间复杂度是o(n),但是两种耗时差不  多。可能是因为数据量给的是10^4,两种时间复杂度都可以轻松应对。 
```

<img src="https://s2.loli.net/2023/10/11/k2BNmIpVf745WXG.png" alt="image.png" style="zoom: 50%;" />

## 58.最后一个单词的长度（指针，参考分治左、中、右）

```js
输入：s = "   fly me   to   the moon  "
输出：4
解释：最后一个单词是“moon”，长度为4。
本来想着while循环一气呵成的，但是末尾的空格问题，属实有一定的影响。
然后想起来，上一题的"小分治---左、中、右"，为什么不能给他分开呢?
最后返回length;
```

<img src="https://s2.loli.net/2023/10/11/WEzyBVTS3NkLiRt.png" alt="image.png" style="zoom:50%;" />
