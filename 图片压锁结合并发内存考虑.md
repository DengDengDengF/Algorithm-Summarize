[TOC]



### 1.图片压缩结合并发内存考虑

![image.png](https://s2.loli.net/2025/12/25/G4t7COv5kbZQAxP.png)

```js
图片压缩占用内存再100mb，以内体验最好。故而，把12mb以上的直接pass了。
确保并发过程中内存占用始终100mb上下
已知，接口同时并发5个。
let memoryHash={1:9.6,2:19.2,......,12:115.2}
若有以下文件列表imgSizeList = [2mb,3.1mb,4.2mb,5mb,1mb,2mb,3mb]
const maxlimit = 120
let tempSize = 0,num = 0,oldIndex = 0, newIndex = 0,length = imgSizeList.length
while(newIndex < length){
    while(tempSize < maxlimit && newIndex < length){
      const k = Math.ceil(imgSizeList[newIndex])
      const space = memoryHash(k)
      tempSize += space
      newIndex++
    }
    //oldIndex 到 newIndex区间先去做 worker并发`抽样`MD5 、压缩图片（占内存）
}
想压缩到指定大小 匹配 指定的像素，绝对不能遍历，要根据宽高比一次计算
```

### 2.图片压缩目标公式

#### 2.1 单个压缩

```js

    input.addEventListener('change', async (e) => {
        const file = e.target.files[0]
        if (!file) return
        originImg.src = URL.createObjectURL(file)
        const blob = await compressImageWorkerSafe(file, {
            maxWidth: 1440,
            quality: 0.3,
            type: 'image/jpeg'
        })
        compressImg.src = URL.createObjectURL(blob)
        info.innerHTML = `
      原图：${(file.size / 1024).toFixed(1)} KB<br/>
      压缩后：${(blob.size / 1024).toFixed(1)} KB
    `
    })

    /**
     * Worker-safe Canvas 压缩函数
     * 可直接复制进 worker.js 使用
     */
    async function compressImageWorkerSafe(
        blob,
        { maxWidth = 800, quality = 0.7, type = 'image/jpeg' } = {}
    ) {
        const bitmap = await createImageBitmap(blob)

        const scale = Math.min(1, maxWidth / bitmap.width)
        const width = Math.round(bitmap.width * scale)
        const height = Math.round(bitmap.height * scale)

        const canvas = new OffscreenCanvas(width, height)
        const ctx = canvas.getContext('2d')

        ctx.drawImage(bitmap, 0, 0, width, height)

        const result = await canvas.convertToBlob({
            type,
            quality
        })

        bitmap.close?.()
        return result
    }
```

#### 2.2流程

固定像素尺寸 → 经验猜 quality → 区间微调二分 → 得到最大可用 quality

1.固定像素尺寸
    可以根据像素列表找到

2.经验猜 quality

 a = 0.7 无脑

![image.png](https://s2.loli.net/2025/12/26/Pb2ERnKJshCMOwf.png)



<img src="https://s2.loli.net/2025/12/26/RvjPsbwlB9g5uey.png" alt="image.png" style="zoom: 67%;" />

![image.png](https://s2.loli.net/2025/12/26/4rXRPKD7qcpLdCy.png)

![image.png](https://s2.loli.net/2025/12/26/ZnSMa9CLbweT5NV.png)

#### 2.3函数图像

![image.png](https://s2.loli.net/2025/12/26/yEuUeP8hJSD2trB.png)

![image.png](https://s2.loli.net/2025/12/26/yvgkW7sLP4altez.png)

#### 2.4代码实操

```js
interface CompressOptions {
  maxWidth: number;
  maxHeight?: number;
  type?: string;
}

/**
 * 根据目标文件大小，自动寻找最大可用 quality
 * @param file 图片 File 对象
 * @param targetSize 目标文件大小（字节）
 * @param options 压缩参数（maxWidth/maxHeight/type）
 * @param alpha 幂指数经验值，默认 0.7
 * @param tolerance 容差，文件大小允许略大于 targetSize
 */
async function compressToTargetSize(
  file: File,
  targetSize: number,
  options: CompressOptions,
  alpha = 0.7,//-------------------经验值实际可以降低 0.6 0.7 0.8--------------------------
  tolerance = 1024 // 1KB 容差//-------------------实际可以提高--------------------------
) {
  let low = 0.1;
  let high = 0.95;  //----------------------------实际可以降低----------------------------
  let bestBlob: Blob | null = null;

  // 先试一次中间 quality 作为 probe
  const probeQuality = 0.5; //----------------------------实际可以降低----------------------------
  const probeBlob = await compressImageWorkerSafe(file, {
    ...options,
    quality: probeQuality,
  });
  const sizeProbe = probeBlob.size;

  // 根据公式预估 q_guess
  let qGuess = probeQuality * Math.pow(targetSize / sizeProbe, 1 / alpha);
  qGuess = Math.min(Math.max(qGuess, low), high); // 限制在 [low, high]

  // 在 qGuess 附近 ±0.05 二分法
  low = Math.max(qGuess - 0.05, 0.1);
  high = Math.min(qGuess + 0.05, 0.95);

  const maxIterations = 5;
  for (let i = 0; i < maxIterations; i++) {
    const mid = (low + high) / 2;
    const blob = await compressImageWorkerSafe(file, {
      ...options,
      quality: mid,
    });

    if (blob.size > targetSize + tolerance) {
      high = mid; // 文件太大，降低 quality
    } else {
      low = mid;  // 文件小于目标，尝试更高 quality
      bestBlob = blob; // 保存当前满足条件的 blob
    }

    if (high - low < 0.005) break; // 精度足够
  }

  return bestBlob;
}

```

