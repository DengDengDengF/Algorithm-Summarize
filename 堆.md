# 堆

‘

[TOC]

### 建堆的时间复杂度

![image.png](https://s2.loli.net/2024/07/26/jXqOgUaCelVA2Nr.png)

```js
假如，要一组数组中的最大值，用建堆的方式 vs Math.max,表面上看都是o(n),时间上堆时间复杂度是在最坏的情况下是比o(n)要高的！
Math.max恒定o(n)。
```



### 264.丑数II

```js
给你一个整数 n ，请你找出并返回第 n 个 丑数 。
丑数 就是质因子只包含 2、3 和 5 的正整数。
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
用最小堆算法
 function nthUglyNumber(n) {
        let target = [2, 3, 5], res = '';
        //得去重，不然会把重复的最小堆给顶上去
        let seen=new Set();
        let arr = [1];
        for (let i = 0; i < n; i++) {
            [arr[arr.length - 1], arr[0]] = [arr[0], arr[arr.length - 1]]
            res = arr.pop();
            for (let val of target) {
                const next=val * res;
                if(!seen.has(next)){
                    seen.add(next)
                    arr.push(next);
                }
            }
            for (let j = Math.floor(arr.length / 2) - 1; j >= 0; j--) {
                //小根堆
                Sort(arr, arr.length, j);
            }
        }
        return res;
}
```

### 378.有序矩阵中第K小的元素

```java
给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。

你必须找到一个内存复杂度优于 O(n2) 的解决方案。
输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
输出：13
解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
    
利用矩阵特点之一:行元素升序排列，每一行第一个元素是这一行最小的，每一次弹出的元素都在每一行的第一列中。
蓝色的就是候选值，可以用最小堆每次把堆顶元素弹出来
    
时间复杂度：O(klogn)，归并 k 次，每次堆中插入和弹出的操作时间复杂度均为 logn。
空间复杂度：O(n)，堆的大小始终为 n。
```

<img src="https://pic.leetcode-cn.com/74c293951b7e63823776f6acd1bab58c2277b5a09caa4b926940aa4af9c6be98-gaitubao_%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-07-02%20%E4%B8%8B%E5%8D%886.41.52%20(1).png" alt="png" style="zoom:33%;" />
