[TOC]



### 1.基本性质

前提：二叉搜索树（`左  < 根 <右`）

根和叶子(null)都是黑   `根叶黑`  

红色节点的左右孩子都是黑色（上下级之间，不存在连续的两个红色节点） `不红红`

任一节点到叶子节点所有路径黑节点数量相同  `黑路同`

![image.png](https://s2.loli.net/2024/09/07/5rQxWGKg1UXv32D.png)

最长路径不超过最短路径两倍（任一节点左右子树的高度差`不超过两倍`）

![image.png](https://s2.loli.net/2024/09/07/JjzcCa7sOWX4ngp.png)

### 2.为啥null节点还要黑色？

维护 ` 黑路同`

<img src="https://s2.loli.net/2024/09/07/7HcodnTyOSq4wuA.png" alt="image.png" style="zoom: 50%;" /><img src="https://s2.loli.net/2024/09/07/GLbvKPpTuoCyNtd.png" alt="image.png" style="zoom:50%;" />

不关联null节点，表面上看符合红黑树性质。

关联null节点，就不符合了，破坏了 `黑路同`

null节点，每个节点都有，用null节点就是在维护红黑树性质 `黑路同`



### 3.为啥插入节点是红色?

如果插入节点是黑色节点，直接影响 ` 黑路同 `。

 <img src="https://s2.loli.net/2024/09/07/HMJz1oewE7cQp6V.png" alt=" 2024-09-07 141326.png" style="zoom: 50%;" />

如果插入节点是红色节点， 不会影响 `黑路同`，可能影响 `不红红`

<img src="https://s2.loli.net/2024/09/07/rd7vSAEMW4K9Xnl.png" alt=" 2024-09-07 141605.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/09/07/LQjSknKZmif5zbH.png" alt="image.png" style="zoom:50%;" />

所以选择插入红色节点，影响更小

### 4.插入红色节点后，红黑树性质遭到破坏咋办?

插入节点默认红色节点，

插入后红黑树性质破坏，根据以下三种情况调整：确保最长路径不超过最短路径两倍

1.违反`根叶黑`

插入节点是根节点---------->直接变黑



2.违反`不红红`,父节点红色

插入节点的叔叔是红色--------->叔父爷变色，**爷爷变插入节点**

插入节点的叔叔是黑色----------->（LL,RR,LR,RL）旋转，然后对`旋转中心`和`旋转点`变色

所谓 LL,RR,....是父节点的`L/R`节点的`L/R`子树





### 5.插入逻辑，代码构思

1.寻找插入位置`node`，返回查找栈`stack`

2.插入位置`red`，如果破坏性质

​    2.1.破坏根叶黑，

```
  这里的判断只能是根，即stack.length=0;改变`black`
```

​    2.2.破坏不红红   

​          2.2.1插入节点的叔叔是`red`

```js
  let  grandFather= stack[stack.length-2];
  let  father=stack[stack.length-1];
  let  uncle;
  if(grandFather.l === father){
       uncle=grandFather.r;
       if(uncle.color === "red"){
           //这里可以加判断 红变黑 黑变红
           grandFather.color = "red";
           grandFather.l.color="black"
           grandFather.r.color="black"
           //这里封装函数，传入的是grandFather
       }
  }else{
      uncle=grandFather.l;
      if(uncle.color === "red"){
           grandFather.color = "red";
           grandFather.l.color="black"
           grandFather.r.color="black"
          //这里封装函数，传入的是grandFather
       }
  }
```

​          2.2.2插入节点的叔叔是`black`

```js
  let  grandFather= stack[stack.length-2];
  let  father=stack[stack.length-1];
  let  uncle;
  if(grandFather.l === father){
       uncle=grandFather.r;
       if(uncle.color === "black"){
            if(father.l === node){
               //LL
             }else{
               //LR
            }
       }
  }else{
      uncle=grandFather.l;
      if(uncle.color === "black"){
           if(father.l === node){
             //RL
           }else{
             //RR
           }
      }
  }

```

 逻辑构思完毕，1小时内拿下！ 提供一个demo去想象！                                         

<img src="https://s2.loli.net/2024/09/07/gLWGbsieqrDvlE5.png" alt="image.png" style="zoom:50%;" />

### 6.插入

 这里的`makeRedBlackTree` 红黑树递归纠正函数，可以改成栈

 chatgpt说，因为js引擎有最大递归深度限制，几十亿数据量可能会爆炸。太累了，不想改了，下次一定！

```js
    //默认的结构，抽象 red对应true,black对应false
    function structure() {
        return {val: null, left: null, right: null, color: true};
    }

    /**
     * @param{Object} tree 红黑树根节点
     * @param{Number} target 要插入的目标值
     * @return{Array} 查找栈*/
    function search(tree, target) {
        let stack = [];
        while (tree) {
            stack.push(tree);
            if (target > tree.val) {
                tree = tree.right;
            }
            if (target < tree.val) {
                tree = tree.left
            } else {//重复
                return [];
            }
        }
        return stack;
    }

    /**插入节点的叔叔是红色--------->叔父爷变色
     * @param{Object} node  爷爷节点
     * @return{void}*/
    function colorChange(node) {
        node.color = !node.color;
        if (node.left) node.left.color = !node.left.color;
        if (node.right) node.right.color = !node.right.color;
    }

    /**对`旋转中心`和`旋转点`变色
     * @param{Object} node1  旋转中心
     * @param{Object} node2  旋转点
     * @return{void}*/
    function colorChange2(node1, node2) {
        node1.color = !node1.color;
        node2.color = !node2.color;
    }

    /** 左旋后,
     * @param{Object} tree 爷爷节点
     * @return {void}*/
    function leftRotate(tree) {
        let right = tree.right.left;
        let temp = structure();
        temp.val = tree.val;
        temp.left = tree.left;
        temp.right = right;
        temp.color = tree.color;

        tree.val = tree.right.val;
        tree.color = tree.right.color;
        tree.left = temp;
        tree.right = tree.right.right;
    }

    /**右旋后,
     * @param{Object} tree 爷爷节点
     * @return {void}*/
    function rightRotate(tree) {
        let left = tree.left.right;
        let temp = structure();
        temp.val = tree.val;
        temp.left = left;
        temp.right = tree.right;
        temp.color = tree.color;

        tree.val = tree.left.val;
        tree.color = tree.left.color;
        tree.left = tree.left.left;
        tree.right = temp;

    }

    /**
     * @param{Object}  node 插入节点
     * @param {Array} stack 插入节点的祖先栈*/
    function makeRedBlackTree(node, stack) {
        if (stack.length === 0) {//使其满足 `根叶黑`
            node.color = false;
        } else {//使其满足 `不红红`
            let father = stack.pop();
            if (father.color) {//父节点红色
                let grandFather = stack.pop();
                if (!grandFather.left) { //叔叔节点是null 在爷爷节点 左侧 是黑色;  父节点  在爷爷节点右侧 是红色
                    if (father.left === node) {
                        //RL
                        rightRotate(father);
                        leftRotate(grandFather);
                        colorChange2(grandFather, grandFather.left);
                    } else {
                        //RR
                        leftRotate(grandFather);
                        colorChange2(grandFather, grandFather.left);
                    }
                } else if (!grandFather.right) {//叔叔节点是null 在爷爷节点 右侧 是黑色； 父节点  在爷爷节点左侧 是红色
                    if (father.left === node) {
                        //LL
                        rightRotate(grandFather);
                        colorChange2(grandFather, grandFather.right);
                    } else {
                        //LR
                        leftRotate(father);
                        rightRotate(grandFather);
                        colorChange2(grandFather, grandFather.right);
                    }
                } else {//叔叔节点不是null,继续判断是 红色?黑色?
                    let uncle;
                    if (grandFather.left === father) { //爷爷节点 的 左节点 是 父节点
                        uncle = grandFather.right;
                        if (uncle.color) {//叔叔节点是 红色
                            colorChange(grandFather);
                            makeRedBlackTree(grandFather, stack);
                        } else {//叔叔节点是 黑色
                            if (father.left === node) {
                                //LL
                                rightRotate(grandFather);
                                colorChange2(grandFather, grandFather.right);
                            } else {
                                //LR
                                leftRotate(father);
                                rightRotate(grandFather);
                                colorChange2(grandFather, grandFather.right);
                            }
                        }
                    } else {//爷爷节点 的 右节点 是 父节点
                        uncle = grandFather.left;
                        if (uncle.color) {
                            colorChange(grandFather);
                            makeRedBlackTree(grandFather, stack);
                        } else {
                            if (father.left === node) {
                                //RL
                                rightRotate(father);
                                leftRotate(grandFather);
                                colorChange2(grandFather, grandFather.left);
                            } else {
                                //RR
                                leftRotate(grandFather);
                                colorChange2(grandFather, grandFather.left);
                            }
                        }
                    }
                }
            }
            //父节点黑色，满足红黑树性质
        }
    }

    /**
     * @param{Array} arr 不重复的数组
     * @return {Object} 红黑树*/
    function main(arr) {
        if (arr.length < 1) return null;
        let tree = structure();
        tree.val = arr[0];
        tree.color = false;
        for (let i = 1; i < arr.length; i++) {
            let stack = search(tree, arr[i]);
            if(stack.length > 0){
                let father = stack[stack.length - 1];
                //按照二叉搜索树的方式添加红色节点
                if (arr[i] > father.val) {
                    father.right = structure();
                    father.right.val = arr[i];
                    father.right.color = true;
                    makeRedBlackTree(father.right, stack);//校验红黑树
                } else {
                    father.left = structure();
                    father.left.val = arr[i];
                    father.left.color = true;
                    makeRedBlackTree(father.left, stack);//校验红黑树
                }
            }
        }
        return tree;
    }
```

