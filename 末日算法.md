# 末日算法

**末日算法是由数学家约翰·霍顿·康威（John Horton Conway）创造的**

这个数学家，找出了一些规律，如下：

![2025-09-15 21.22.48.jpeg](https://s2.loli.net/2025/09/16/q5d8u7bnYzEjSBG.jpg)

某年的，若干日子总是同一个星期几。

特殊的，闰年：1月4，2月有29天

​               平年：1月3，2月有28天



通过以上规律，只是知道某年有某些日期星期几一样，如果要知道某年某月末日是星期几呢？

可以做从某年某月末日做推导，如下：

 ![2025-09-15 21.29.30.jpeg](https://s2.loli.net/2025/09/16/bPdyXsDGR2WLAeh.jpg)

周日，周五，周三，周二百年循环，我们只要知道2000年周二就可以了。

2000年-2099年啥规律呢，如下：

![2025-09-16 20.45.20.jpeg](https://s2.loli.net/2025/09/16/yA43wTYklCjKPt1.jpg)

没错！是平年=上一年+1，闰年=上一年+2

例如 2020年的世界末日是周几呢？

```
2000
2001
2002
2003
2004✅
2005
2006
2007
2008✅
2009
2010
2011
2012✅
2013
2014
2015
2016✅
2017
2018
2019
2020✅

画着✅的是闰年，有（2020 - 2000）/4 = 5 个
周日 周一 周二 周三 周四 周五 周六
         👊
从周二开始 数（2020-2000） + （2020-2000） /4  = 25 次 是周六！
```

如果，用代码实现呢

```java
package chapter1.section2;

import edu.princeton.cs.algs4.StdOut;

/**
 * Created by Rene Argento
 * Doomsday algorithm implemented by Junaid Ashraf (aka sickboy)
 */
public class Exercise12 {
    private final int month;
    private final int day;
    private final int year;

    private final String[] daysOfWeek = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    private final int[] daysInMonths = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    public Exercise12(int month, int day, int year) {
        if (year % 4 != 0) { // not a leap year
            daysInMonths[1] = 28;
        }
        if (!isDateValid(month, day, year)) {
            throw new RuntimeException("Invalid date!");
        }
        this.month = month;
        this.day = day;
        this.year = year;
    }

    public int month() {
        return month;
    }

    public int day() {
        return day;
    }

    public int year() {
        return year;
    }

    public String toString() {
        return month() + "/" + day() + "/" + year();
    }

    private boolean isDateValid(int month, int day, int year) {
        return year >= 1
                && month >= 1 && month <= 12
                && day >= 1 && day <= daysInMonths[month - 1];
    }

    /**
     * Returns doomsday for any year in the 21st century
     * More info: <link href="https://www.youtube.com/watch?v=z2x3SSBVGJU">Doomsday algorithm: numberphile</link>
     *
     * @return index of doomsday of current year
     */
    public int getDoomsday() {
        if (year < 2000 || year > 2100) {
            throw new IllegalArgumentException("Year must be from 21st century");
        }
        int numberOfYears = year % 100;
        // On the year 2000 doomsday was a Tuesday. With this information, we can compute the doomsday of any
        // other year.
        // doomsday = (tuesday(3) + number of years from 2000 + number of leap years) % 7
        int doomsday = 2 + numberOfYears + (numberOfYears / 4);

        // If it is a leap year then doomsday will be on January 4th. Otherwise, it will be on January 3rd.
        // From here we can compute the weekday name of January 1st for the current year.
        if (year % 4 == 0) {
            return doomsday + 3;
        } else {
            return doomsday + 4;
        }
    }

    /**
     * @return day of the week
     */
    public String dayOfTheWeek() {
        int numberOfDays = day;
        for (int i = 0; i < month - 1; i++) {
            numberOfDays += daysInMonths[i];
        }
        int dayOfWeek = (numberOfDays + getDoomsday()) % 7;
        return daysOfWeek[dayOfWeek];
    }

    public static void main(String[] args) {
        Exercise12 smartDate1 = new Exercise12(4, 18, 2020);
        StdOut.println(smartDate1.dayOfTheWeek() + " Expected: Saturday");

        Exercise12 smartDate2 = new Exercise12(6, 15, 2005);
        StdOut.println(smartDate2.dayOfTheWeek() + " Expected: Wednesday");

        Exercise12 smartDate3 = new Exercise12(9, 11, 2001);
        StdOut.println(smartDate3.dayOfTheWeek() + " Expected: Tuesday");

        Exercise12 smartDate4 = new Exercise12(12, 31, 2010);
        StdOut.println(smartDate4.dayOfTheWeek() + " Expected: Friday");

        Exercise12 smartDate5 = new Exercise12(7, 4, 2025);
        StdOut.println(smartDate5.dayOfTheWeek() + " Expected: Friday");

        Exercise12 smartDate6 = new Exercise12(11, 22, 2040);
        StdOut.println(smartDate6.dayOfTheWeek() + " Expected: Thursday");

        Exercise12 smartDate7 = new Exercise12(3, 29, 2050);
        StdOut.println(smartDate7.dayOfTheWeek() + " Expected: Tuesday");

        Exercise12 smartDate8 = new Exercise12(9, 15, 2025);
        StdOut.println(smartDate8.dayOfTheWeek() + " Expected: Monday");
    }
}

最令人费解的就是   
        if (year % 4 == 0) {
            return doomsday + 3;
        } else {
            return doomsday + 4;
        }
为了避免出现负数，
如果是闰年基准日是1.4，得到1.1，就得 -3 即， doomsday - 3 + 7  = doomsday + 4
如果是平年基准日是1.3，得到1.1，就得 -2，即，doomsday - 2 + 7 =doomsday + 5
但是结果是 +3/+4，不是+4/+5，为啥？
因为`int dayOfWeek = (numberOfDays + getDoomsday()) % 7`,这句代码里的numberOfSDays是从1.1算起的，为了避免重复算1.1，就-1，得到+3/+4
```

没办法，这个算法就很神奇！有意义！