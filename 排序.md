## 1.插入排序(少量元素)

<img src="https://s2.loli.net/2023/08/18/89ZoLPTjtJnmkWu.png" alt="image.png" style="zoom: 50%;" />

```js
 function selectionSort() {
        let arr = [5, 15, 3, 27, 26];
        let temp = [];
        for (let i = 1; i < arr.length; i++) {
            let j = i;
            while (j > 0 && arr[j-1] > arr[j]) {
                temp = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = temp;
                j--;
            }
        }
        return arr;
 }
```



## 2.快排

<img src="https://s2.loli.net/2023/08/18/lHUzWaZBMVNceob.png" alt="image.png" style="zoom:33%;" />

```js
    function quickSort(arr) {
        if (arr.length < 2) return arr
        let m = arr[0];
        let l = [], r = [];
        for (let i = 1; i < arr.length; i++) {
           arr[i] < m?l.push(arr[i]):r.push(arr[i])
        }
        return quickSort(l).concat([m], quickSort(r));
    }
```



<img src="https://s2.loli.net/2024/04/16/32IyMRoQ4epJVaH.png" alt="image.png" style="zoom:50%;" />

```js
 //时间复杂度o(nlog(n))  空间复杂度o(log(n))
    function quickSort(arr, left, right) {
        if (left < right) {
            //确保_______middle_____,middle左侧都是比他小的，反之右侧都是比他大的
            let middle = Sort(arr, left, right);
            
            quickSort(arr, left, middle - 1);
            quickSort(arr, middle + 1, right);
        }
    }

    function Sort(arr, left, right) {
        //这里用了一个双指针，init指针和循环指针完成交换
        let init = left - 1;
        let target = arr[right];
        for (let i = left; i < right; i++) {
            if (arr[i] <= target) {
                init++;
                [arr[init], arr[i]] = [arr[i], arr[init]];
            }
        }
        [arr[init + 1], arr[right]] = [arr[right], arr[init + 1]];
        return init + 1;
    }
   let arr = [10, 22, 3, 8, 1, 78, 2, 0, 45]
    quickSort(arr, 0, arr.length - 1)
```



## 3.归并排序

```js
    function Sort(l, r) {
        let res = []
        while (l.length && r.length) {
            if (l[0] > r[0]) {
                res.push(r.shift());
            } else {
                res.push(l.shift());
            }
        }
        if (!l.length) {
            return res.concat(r);
        }
        if (!r.length) {
            return res.concat(l);
        }
    }

    function mergeSort(arr) {
        if (arr.length < 2) return arr;
        let m = Math.floor(arr.length / 2);
        let l = arr.slice(0, m);
        let r = arr.slice(m);
        return Sort(mergeSort(l), mergeSort(r));
    }


//原地排序
    function mergeTo(arr, left, right, mid) {
        let l_start = left;
        let r_start = mid + 1;
        //不要死记硬背，参照队列的方式
        while (l_start <= mid && r_start <= right) {
            if (arr[l_start] <= arr[r_start]) {
                l_start++;
            } else {
                let temp = arr[r_start];
                let k = mid, s = r_start;
                while (k >= l_start) {
                    arr[s] = arr[k]
                    s = k;
                    k--;
                }
                arr[k + 1] = temp;
                r_start++;
                mid++;
                l_start++;
            }
        }
    }

    function mergeSort(arr, left, right) {
        if (left >= right) return;
        const mid = Math.floor((left + right) / 2); // Fix: Use correct mid calculation
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        mergeTo(arr, left, right, mid);
    }
```

<img src="https://s2.loli.net/2023/08/18/WZtR6moNdsJkIhj.png" alt="image.png" style="zoom:50%;" />

## 4.堆排序

<img src="https://s2.loli.net/2023/08/18/NtXMZdY6SafRyqU.png" alt="image.png" style="zoom: 50%;" />

<img src="https://s2.loli.net/2023/08/18/yK3bdczBoD1IflP.png" alt="image.png" style="zoom: 50%;" />

```js
从父到子：
父节点:Math.floor(length / 2) -1;
  左子:2父+1
  右子:2父+2

从子到父:
  左子/右子:n
        父:Math.floor((n-1)/2)

  function Sort(arr, length, i) {
        let max = i;
        let left = 2 * i + 1;
        let right = 2 * i + 2;
        if (left < length && arr[max] < arr[left]) max = left;
        if (right < length && arr[max] < arr[right]) max = right;
        while (max !== i) {
            [arr[max], arr[i]] = [arr[i], arr[max]];
            return Sort(arr, length, max);
        }
    }

    function heapSort(arr) {
        //建堆
        for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {
              Sort(arr, arr.length, i);
        }
        //堆排序
        for (let i = arr.length - 1; i > 0; i--) {
            [arr[i],arr[0]]=[arr[0],arr[i]];
            Sort(arr,i,0)
        }
        return arr;
    }
```

