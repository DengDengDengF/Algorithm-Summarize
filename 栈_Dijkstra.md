[TOC]



### 1.运算

```js
把 `(1 + 2 + 3) * (3 + 4 + 6)`
计算栈
运算符栈
通过出栈、入栈，局部计算
```

### 2.补足左括号

```js
补足左括号`1+2) * 4+6))`，打印结果
计算栈
运算符栈
通过出栈、入栈，局部计算 
‘（’ + a + b + ')'
```

### 3.中序运算转后序运算

```js
中序：左根右
后序：左右根
例如：二叉树版本略，此处做另外的抽象
原来字符=(1+2)
中序: 1 + 2,  后序:1 2 +
计算栈
运算符栈
出两个计算栈 出一个运算符栈
```

### 4.计算后序表达式

```js
1 3 +
数字栈 1 3
字符栈  +

a =数字栈pop();//3
b =数字栈pop();//1
c =字符栈pop();//+
a c b = 1 + 3 = 4

```

### 5.文本缓冲区

![IMG_0728.jpeg](https://s2.loli.net/2025/11/27/xs6Q2kYmarKEzWy.jpg)

```js
Insert:L D F
  F
  _    
  D
  _
  L         
(STACK1) (STACK2 EMPTY)

LEFT(2)
            D
            _
  L         F
(STACK1)   (STACK2)

.......
双栈算法，通过出栈，避免了删除一个元素后面的元素都得移动的情况
```

### 6.校验出栈后的排列是否正确

![IMG_0740.jpeg](https://s2.loli.net/2025/12/01/1XIUWtrdJkYqMwc.jpg)

```js
假设序列 0,1,2......n-1 是按照顺序入栈的，可以中途出栈，给定一个出栈排列，判断是否正确

出栈就是在 递减
入栈就是在 递增

比如，图一中 先出5，再出1，默认2`已经先1`出了。再出2，显然不对
图二中，先出5，再出4，再出3，就可以。因为经过了0-5递增，默认`3，4已经push`进去了。
```

### 7.有限个栈，构成队列，队列的操作通过栈实现必须是常数次

![image.png](https://s2.loli.net/2025/12/10/pDjRYzvy3GgdHbV.png)

```js
这套方案，是基于
1.分块（固定长度）
2.块与块之前通过链表连接
3.`入队列`满了就加块
4.`出队列`要实现，`复制栈底 + 出栈并交换栈底`，也就是我会修改栈底元素，同时满足出栈o(1)
但是，会违反栈的抽象概念
```

