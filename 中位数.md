## 1.寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

分析如下：

为了使用划分的方法解决这个问题，需要理解「中位数的作用是什么」。在统计中，中位数被用来：

```
将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。
```

如果理解了中位数的划分作用，就很接近答案了。

首先，在任意位置 *i* 将 A 划分成两个部分

```
           left_A            |          right_A
    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
```

由于 A 中有 *m* 个元素， 所以有 *m*+1 种划分的方法（ *i* ∈ [0,*m*]  ）。

```
len(left_A)=i,len(right_A)=m−i.

注意：当 i=0 时，left_A 为空集， 而当 i=m 时, right_A 为空集。
```

采用同样的方式，在任意位置 *j* 将 B 划分成两个部分：

```
           left_B            |          right_B
    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
```

将 left_A 和 left_B 放入一个集合，并将 right_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part：

```
          left_part          |         right_part
    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
```

当 A 和 B 的总长度是偶数时，如果可以确认：

- len(left_part) =  len(right_part) 

- max(left_part) ≤ min(right_part)

那么，{A,B} 中的所有元素已经被划分为相同长度的两个部分，且前一部分中的元素总是小于或等于后一部分中的元素。中位数就是前一部分的最大值和后一部分的最小值的平均值：

$$
\text{median} = \frac{\max(\text{left\_part}) + \min(\text{right\_part})}{2}
\
$$
当 A 和 B 的总长度是奇数时，如果可以确认：

- len(left_part) = len(right_part) + 1
- max(left_part) ≤ min(right_part)

那么，{A,B} 中的所有元素已经被划分为两个部分，前一部分比后一部分多一个元素，且前一部分中的元素总是小于或等于后一部分中的元素。中位数就是前一部分的最大值：

$$
\text{median} = \max(\text{left\_part})
$$
第一个条件对于总长度是偶数和奇数的情况有所不同，但是可以将两种情况合并。第二个条件对于总长度是偶数和奇数的情况是一样的。

![2025-08-02 20.44.53.png](https://s2.loli.net/2025/08/02/vqjJS1X2DECioZn.png)

所以我们需要做的是：

![2025-08-02 20.46.59.png](https://s2.loli.net/2025/08/02/p5HL6vSiFAwgJBD.png)



​	
