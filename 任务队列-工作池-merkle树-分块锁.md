# 解决超大文件分块算哈希场景

[TOC]



## 1.极限方案-多线程merkle树原子并发

![IMG_0574.jpeg](https://s2.loli.net/2025/09/27/8eyMn7uPvE6LU9k.jpg)

```js
1.构建marklee树的过程，可以顺便构建双向链表，通过任意节点可以得到兄弟以及父亲
2.其他过程任务队列、工作池、webworker、以及怎么用多线程api略
3.分块锁，
初始化全部无锁，一层一套锁，
第四层h4 2^3 个锁 [ , , , , , , , ]
第三层h3 2^2 个锁 [ , , , ]
第二层h2 2^1 个锁 [ , ]
第一层h1 2^0 个锁 [ ]
H1 和 H2 叶子节点，争抢h4[0],谁争到谁去合并对方，没争到的就作罢
H3 和 H4 叶子节点，争抢h4[1],谁争到谁去合并对方，没争到的就作罢
......
H15 和 H16 叶子节点，争抢h4[7],谁争到谁去合并对方，没争到的就作罢

H1_2 和 H3_4非叶子节点，争抢h3[0],谁争到谁去合并对方，没争到的就作罢
......
H13_14 和 H15_16非叶子节点，争抢h3[3],谁争到谁去合并对方，没争到的就作罢

直到H1_16....

tips:但是会出现并发递减的现象，在剩下的任务数量 < 并发数下，处理哈希合并忽略不计

4.主要考虑的是模型的实现，工程细节略
```

### 1.1共享内存 对象转换

####    1.1.1 固定字段顺序布局![image.png](https://s2.loli.net/2025/10/23/TFk2aUVdDZiszYm.png)

####     1.1.2 偏移表布局

​     就是非固定的字段的顺序布局

```js
[value,maxChildrenNum,index1,index2,....indexN]
maxChildrenNum 是树的最大孩子数量
```

####     1.1.3 层序展开

```
      A
     / \
    B   C
       /
      D
[A, B, C, null, null, D,null] 这里默认maxChidrenNum = 2 ，二叉树
如果多叉树，maxChidrenNum还得先计算
```

####     1.1.4 结构体布局

![image.png](https://s2.loli.net/2025/10/23/MV6BzeXdQrjUfPs.png)

```
也得知道树的最大孩子数量
```

### 1.2 综述

```js
综上，说的都是一回事， "怎么扁平化"。
工程实现，扁平细节直接略，默认已经配置好共享数据了，把共享数据、该节点以后的路径、都postmessage过去、并发原子锁就基于这个共享内存。
```



## 2.简单方案-多文件并发，顺序md5

```js
1.任务队列+工作池+webworker，多文件并发计算，
2.单文件计算，依次md5 append
```

## 3.方案选择

```js
带宽、性能、代码维护成本、业务规模综合考量。
IF (前端哈希结果会被后端“直接信任并入库”) THEN
    必须全量哈希
ELSE IF (后端还会读取文件校验) THEN
    可以抽样
ELSE IF (只是做秒传或断点续传标识) THEN
    抽样更优
```

## 4.桌面端（Electron） vs 浏览器（chrome）

```js
─────────────────────────────
        浏览器 (Chrome)
─────────────────────────────
浏览器主进程 (Browser Process)
    ├─ 管理标签页、窗口
    ├─ 网络、缓存、插件
    └─ 调度渲染进程
          │ IPC / 消息
渲染进程 (Tab / Renderer Process)
    ├─ 主线程 (JS + UI)
    │     - 执行 JS
    │     - 处理 DOM / 事件
    │     - 布局 / 样式计算 / 重绘
    ├─ 绘制线程 (Paint / GPU)
    │     - 将 DOM 树渲染到屏幕
    └─ Worker / Service Worker
          - 独立线程执行 JS，不阻塞 UI

─────────────────────────────
        Electron
─────────────────────────────
主进程 (Main Process)
    ├─ 主线程 (JS)
    │     - 管理 BrowserWindow
    │     - 调用 Node API（文件/网络/子进程）
    │     - CPU 密集任务（会阻塞主进程，但不阻塞渲染进程 UI）
    └─ Worker / 子进程
          - 重计算 / IO / 压缩 / 哈希

渲染进程 (Renderer Process)
    ├─ 主线程 (JS + UI)
    │     - 执行前端框架 JS
    │     - 处理 DOM / UI / 事件
    │     - 布局 / 样式 / 重绘
    │     - 与主进程通信 (ipcRenderer)
    ├─ 绘制线程 (Paint / GPU)
    │     - 渲染 DOM / Canvas 到屏幕
    └─ Worker / Node Worker / 子进程
          - 重计算 / CPU 密集任务，不阻塞 UI


```

## **4.1 对比总结**

| 维度     | 渲染进程 Worker                  | 主进程 Worker / 子进程              |
| -------- | -------------------------------- | ----------------------------------- |
| 作用域   | 渲染进程内，靠近 UI              | 主进程内，后台任务                  |
| UI 阻塞  | 不阻塞 UI                        | 不阻塞渲染进程 UI（主进程阻塞除外） |
| Node API | 受限，需要 ipc 与主进程通信      | 完全可用 Node API                   |
| 适用场景 | 前端计算、哈希、排序、大数据处理 | 文件处理、压缩、数据库、网络        |
| 通信方式 | postMessage / ipcRenderer        | ipcMain / ipcRenderer               |
| 生命周期 | 与渲染进程相关                   | 独立于渲染进程，可持续存在          |

------

💡 **核心原则**：

- **UI 相关计算 → 渲染进程 Worker**
- **系统/IO 后台计算 → 主进程 Worker / 子进程**
- 通过 IPC 通信交换数据，保证界面流畅
